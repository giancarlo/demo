/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@cxl/ui@5.0.0-beta.19/chart-engine.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const t=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);const n=[1,1,1,1];const e=[0,0,0,1];function o(n){return n?new Float32Array(n):t.slice(0)}function r(t,n,e){const o=document.createElement("canvas");return o.width=t,o.height=n,e&&e.appendChild(o),o}function a(t,n){const e=r(t,n).getContext("webgl2");if(!e)throw new Error("Could not create webgl2 canvas context");return e}function i(t){return new Promise(((n,e)=>{const o=new Image;o.src=t,o.addEventListener("load",(()=>n(o))),o.addEventListener("error",(()=>e(o)))}))}function c(t,n){return!(t.x+t.w<=n.x||t.x>=n.x+n.w||t.y+t.h<=n.y||t.y>=n.y+n.h)}function u(t,n,e){const o=t.createShader(e);if(!o)throw new Error("Could not create shader.");if(t.shaderSource(o,n),t.compileShader(o),!t.getShaderParameter(o,t.COMPILE_STATUS)){const n=t.getShaderInfoLog(o);throw new Error(`Could not compile shader.\n${n}`)}return o}function l(t,n,e,o,r,a){return new Float32Array([2/(n-t),0,0,0,0,2/(o-e),0,0,0,0,2/(r-a),0,(t+n)/(t-n),(e+o)/(e-o),(r+a)/(r-a),1])}function s({frag:t,vtx:n,canvas:e}){const o=e.getContext("webgl2");if(!o)throw new Error("Could not create webgl2 canvas context");const r=o.createProgram();if(!r)throw new Error("Could not create WebGL Program");const a=u(o,n,o.VERTEX_SHADER),i=u(o,t,o.FRAGMENT_SHADER);if(o.attachShader(r,a),o.attachShader(r,i),o.linkProgram(r),!o.getProgramParameter(r,o.LINK_STATUS))throw o.deleteProgram(r),new Error("Could not create WebGL Program");return{gl:o,glProgram:r}}function f(t,n,e=new Float32Array(16)){const[o,r,a,i,c,u,l,s,f,m,d,_,x,v,g,T]=t,[h,A,E,w,R,p,F,b,P,U,D,L,y,M,B,N]=n;return e[0]=h*o+A*c+E*f+w*x,e[1]=h*r+A*u+E*m+w*v,e[2]=h*a+A*l+E*d+w*g,e[3]=h*i+A*s+E*_+w*T,e[4]=R*o+p*c+F*f+b*x,e[5]=R*r+p*u+F*m+b*v,e[6]=R*a+p*l+F*d+b*g,e[7]=R*i+p*s+F*_+b*T,e[8]=P*o+U*c+D*f+L*x,e[9]=P*r+U*u+D*m+L*v,e[10]=P*a+U*l+D*d+L*g,e[11]=P*i+U*s+D*_+L*T,e[12]=y*o+M*c+B*f+N*x,e[13]=y*r+M*u+B*m+N*v,e[14]=y*a+M*l+B*d+N*g,e[15]=y*i+M*s+B*_+N*T,e}function m(t,n,{internalFormat:e,src:o}){t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e??t.RGBA,e??t.RGBA,t.UNSIGNED_BYTE,o)}function d(t,n){n.wrapS??=t.CLAMP_TO_EDGE,n.wrapT??=n.wrapS;const e=t.createTexture();if(!e)throw new Error("Could not create texture");return t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,n.wrapS),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,n.wrapT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,n.minFilter??t.NEAREST),n.magFilter&&t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,n.magFilter),n.src&&t.texImage2D(t.TEXTURE_2D,0,n.internalFormat??t.RGBA,n.internalFormat??t.RGBA,t.UNSIGNED_BYTE,n.src),e}function _(t,n){const e=n.map((t=>255*t));return d(t,{src:new ImageData(new Uint8ClampedArray([...e,...e,...e,...e]),2,2),minFilter:t.NEAREST,magFilter:t.NEAREST})}function x({canvas:o}){function r(){const t=v.createBuffer();if(!t)throw new Error("Could not create buffer");return t}function a(t,n,e){v.activeTexture(v.TEXTURE0+e),v.bindTexture(v.TEXTURE_2D,t),v.uniform1i(n,e)}function i(t){v.uniformMatrix4fv(A,!1,t)}function c(t,n,{data:e,size:o,normalized:r,type:a,stride:i,offset:c}){v.bindBuffer(v.ARRAY_BUFFER,t),v.vertexAttribPointer(n,o??2,a??v.FLOAT,r??!1,i??0,c??0),v.bufferData(v.ARRAY_BUFFER,e,v.STATIC_DRAW)}function u(t){t.size??=3,c(L,p,t)}function m(t){S!==t&&(w&&a(t,w,0),S=t)}function x(){u({data:Y.buffer})}const{gl:v,glProgram:g}=s({frag:"#version 300 es\nprecision mediump float;\n\nin vec3 v_normal;\nin vec3 v_position;\nin vec2 v_texcoord;\nin vec3 v_tangent;  \n\nuniform sampler2D u_texture;\nuniform sampler2D u_normalTexture;\nuniform sampler2D u_metallicTexture;\nuniform sampler2D u_roughnessTexture;\nuniform sampler2D u_aoTexture;\nuniform vec3 u_lightPosition;\nuniform vec3 u_cameraPosition;\nuniform vec4 u_color;\n\nuniform int u_renderMode; // 0 = unlit, 1 = PBR lit\n\nout vec4 outColor;\n\n#define PI 3.14159265359\n\n// Function to transform normal from tangent space to world space\nvec3 getNormalFromMap() {\n    vec3 tangentNormal = texture(u_normalTexture, v_texcoord).rgb * 2.0 - 1.0;\n    \n    vec3 N = normalize(v_normal);\n    vec3 T = normalize(v_tangent);\n    vec3 B = normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n    \n    return normalize(TBN * tangentNormal);\n}\n\nvec4 calculateLighting(vec4 albedo, float metallic, float roughness, float ao, vec3 normal, vec3 fragPos) {\n    vec3 lightColor = vec3(1.0);\n    vec3 lightDir = normalize(u_lightPosition - fragPos);\n    vec3 viewDir = normalize(u_cameraPosition - fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    \n    float distance = max(length(u_lightPosition - fragPos), 1e-6);\n    float attenuation = 1.0 / (distance * distance);\n    vec3 radiance = lightColor * attenuation;\n    \n    // Ambient\n    vec4 ambient = ao * albedo;\n    \n    // Diffuse (Lambertian)\n    float dotNormalLight = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = dotNormalLight * albedo.rgb;\n    \n    // Specular (Cook-Torrance BRDF)\n    float roughnessSq = roughness * roughness;\n    \n    // Avoid division by zero\n    float NdotH = max(dot(normal, halfwayDir), 0.0001);\n    float dotNormalView = max(dot(normal, viewDir), 0.0001);\n    float VdotH = max(dot(viewDir, halfwayDir), 0.0001);\n    \n    // Distribution (Trowbridge-Reitz / GGX)\n    float nom = roughnessSq;\n    float denom = (NdotH * NdotH * (roughnessSq - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    float distribution = nom / max(denom, 1e-6);\n    \n    // Fresnel-Schlick approximation with metallic\n    vec3 F0 = mix(vec3(0.04), albedo.rgb, metallic);\n    // Fixed: Use VdotH instead of dot(normal, viewDir)\n    vec3 fresnel = F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n    \n    // Geometry (Smith's method with Schlick-GGX)\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    float GGX1 = dotNormalView / (dotNormalView * (1.0 - k) + k);\n    float GGX2 = dotNormalLight / (dotNormalLight * (1.0 - k) + k);\n    float geometry = GGX1 * GGX2;\n    \n    vec3 specular = (distribution * geometry * fresnel) / max(4.0 * dotNormalLight * dotNormalView, 0.0001);\n    \n    // Only add specular if dotNormalLight is positive\n    vec3 finalSpecular = dotNormalLight > 0.0 ? specular : vec3(0.0);\n    \n    return vec4(ambient.rgb + radiance * (diffuse + finalSpecular), albedo.a);\n}\n\nvoid main() {\n    vec4 albedo = texture(u_texture, v_texcoord) * u_color;\n\t\n\t// UNLIT BRANCH\n    if (u_renderMode == 0) {\n        outColor = albedo;\n        return;\n    }\n    \n    // Use the proper normal map transformation\n    vec3 normal = getNormalFromMap();\n    \n    float metallic = texture(u_metallicTexture, v_texcoord).r;\n    float roughness = texture(u_roughnessTexture, v_texcoord).r;\n    float ao = texture(u_aoTexture, v_texcoord).r;\n    \n    outColor = calculateLighting(albedo, metallic, roughness, ao, normal, v_position);\n}\n",vtx:"#version 300 es\nprecision highp float;\n\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texcoord;\nin vec3 a_tangent;\n/*in vec4 a_model0;\nin vec4 a_model1;\nin vec4 a_model2;\nin vec4 a_model3;*/\n\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_projection;\nuniform mat4 u_normalMatrix;\n\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_texcoord;\nout vec3 v_tangent;\n\nvoid main() {\n    vec4 worldPosition = u_model * vec4(a_position, 1.0);\n    v_position = worldPosition.xyz;\n    v_normal = normalize(mat3(u_normalMatrix) * a_normal);\n    v_tangent = normalize(mat3(u_normalMatrix) * a_tangent);\n    v_texcoord = a_texcoord;\n\n    gl_Position = u_projection * u_view * worldPosition;\n}\n\t\t",canvas:o});v.useProgram(g),v.clearColor(0,0,0,0),v.clear(v.COLOR_BUFFER_BIT|v.DEPTH_BUFFER_BIT),v.enable(v.BLEND),v.pixelStorei(v.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),v.blendFunc(v.SRC_ALPHA,v.ONE_MINUS_SRC_ALPHA);const T=v.getUniformLocation(g,"u_model"),h=v.getUniformLocation(g,"u_view"),A=v.getUniformLocation(g,"u_projection"),E=v.getUniformLocation(g,"u_normalMatrix"),w=v.getUniformLocation(g,"u_texture"),R=v.getUniformLocation(g,"u_renderMode"),p=v.getAttribLocation(g,"a_position"),F=v.getAttribLocation(g,"a_texcoord"),b=v.getAttribLocation(g,"a_normal"),P=v.getAttribLocation(g,"a_tangent"),U=v.getUniformLocation(g,"u_color"),D=r(),L=r(),y=r(),M=r(),B=r(),N=l(0,v.canvas.width,v.canvas.height,0,-1,1);let S,C=n;const I=_(v,e),G=_(v,e),X=_(v,e),z=_(v,n);v.bindBuffer(v.ARRAY_BUFFER,y),v.bufferData(v.ARRAY_BUFFER,new Float32Array([0,0,1,0,1,1,1,1,0,1,0,0]),v.STATIC_DRAW);const Y=new Float32Array([0,0,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0]);v.bindBuffer(v.ARRAY_BUFFER,L),v.bufferData(v.ARRAY_BUFFER,Y,v.STATIC_DRAW),v.enableVertexAttribArray(p),v.vertexAttribPointer(p,3,v.FLOAT,!1,0,0);const H=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1]);v.bindBuffer(v.ARRAY_BUFFER,M),v.bufferData(v.ARRAY_BUFFER,H,v.STATIC_DRAW),v.enableVertexAttribArray(b),v.vertexAttribPointer(b,3,v.FLOAT,!1,0,0);const O=new Float32Array([1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0]);v.bindBuffer(v.ARRAY_BUFFER,D),v.bufferData(v.ARRAY_BUFFER,O,v.STATIC_DRAW),v.enableVertexAttribArray(P),v.vertexAttribPointer(P,3,v.FLOAT,!1,0,0),v.uniformMatrix4fv(T,!1,t),v.uniformMatrix4fv(h,!1,t),v.uniformMatrix4fv(A,!1,N),v.uniformMatrix4fv(E,!1,t),v.bindBuffer(v.ARRAY_BUFFER,y),v.enableVertexAttribArray(F),v.vertexAttribPointer(F,2,v.FLOAT,!1,0,0),v.uniform4fv(U,C);const V=[],W=v.getUniformLocation(g,"u_normalTexture"),k=v.getUniformLocation(g,"u_metallicTexture"),j=v.getUniformLocation(g,"u_roughnessTexture"),q=v.getUniformLocation(g,"u_aoTexture"),K=v.getUniformLocation(g,"u_lightPosition"),$=v.getUniformLocation(g,"u_cameraPosition");let J=t;return v.uniform3fv(K,[.5,.5,1]),v.uniform3fv($,[0,0,1]),W&&a(I,W,1),k&&a(G,k,2),j&&a(X,j,3),q&&a(z,q,4),v.viewport(0,0,v.canvas.width,v.canvas.height),v.activeTexture(v.TEXTURE0),i(N),x(),{canvas:v.canvas,clear:function(){v.clear(v.COLOR_BUFFER_BIT|v.DEPTH_BUFFER_BIT)},resizeViewport:function(t,n){v.viewport(0,0,t,n)},setRenderMode:function(t){v.uniform1i(R,"draw"===t?0:1)},pushMatrix(n){V.push(J),n!==t&&(J=J===t?n:f(J,n),v.uniformMatrix4fv(T,!1,J))},popMatrix(){const t=V.pop();if(!t)throw new Error("Matrix stack empty");J=t,v.uniformMatrix4fv(T,!1,t)},get color(){return C},set color(t){t!==C&&v.uniform4fv(U,C=t)},setIndices:function(t){v.bindBuffer(v.ELEMENT_ARRAY_BUFFER,B),v.bufferData(v.ELEMENT_ARRAY_BUFFER,t,v.STATIC_DRAW)},setPosition:u,setNormal:function(t){t.size??=3,c(M,b,t)},setProjectionMatrix:i,setNormalMatrix:function(t){v.uniformMatrix4fv(E,!1,t)},resetPosition:x,resetProjectionMatrix(){i(N)},setTexture:m,createTexture:d.bind(0,v),createColorTexture:_.bind(0,v),updateTexture(t,n){m(t),v.texImage2D(v.TEXTURE_2D,0,n.internalFormat??v.RGBA,n.internalFormat??v.RGBA,v.UNSIGNED_BYTE,n.src)},draw(){v.drawArrays(v.TRIANGLES,0,6)},drawElements:v.drawElements.bind(v)}}function v(t,n=new Float32Array(16)){const{x:e,y:o,sx:r,sy:a,cx:i,cy:c,w:u,h:l,rotation:s}=t;n[2]=n[3]=n[6]=n[7]=n[8]=n[9]=n[11]=n[14]=0,n[10]=n[15]=1;const f=Math.cos(s),m=Math.sin(s);return n[0]=r*f,n[1]=r*m,n[4]=a*-m,n[5]=a*f,n[12]=n[0]*-i+n[4]*-c+e,n[13]=n[1]*-i+n[5]*-c+o,n[0]*=u,n[1]*=u,n[4]*=l,n[5]*=l,n}function g(t){return{x:0,y:0,w:0,h:0,sx:1,sy:1,cx:0,cy:0,rotation:0,...t}}function T(t){function e(n){t.pushMatrix(n),t.draw(),t.popMatrix()}function r(t,n,o,r){const a=(t-w)*p,i=(n-R)*F,c=(o-w)*p,u=(r-R)*F,l=Math.hypot(c-a,u-i),s=Math.atan2(u-i,c-a);d.x=a,d.y=i,d.w=l,d.rotation=s,v(d,f),e(f)}function a(t,n,e,o,r){t[0]=o*p,t[5]=r*F,t[12]=(n-w)*p,t[13]=(e-R)*F}function i(t,n,e,o,a,i){const c=Math.PI/e/4;(o%=2*Math.PI)>=(a%=2*Math.PI)&&(a+=2*Math.PI);let u=t+Math.cos(o)*e,l=n-Math.sin(o)*e;for(let i=o+c;i<a;i+=c)r(u,l,u=t+Math.cos(i)*e,l=n-Math.sin(i)*e)}function c(n,e,o,r){x=l(0,1,0,1,-1,1),w=n,R=e,p=1/(o-n),F=1/(r-e),A=1/t.canvas.width,E=1/t.canvas.height,u()}function u(){s[0]=T=A,s[5]=h=E,d.h=h,d.cx=T/2,d.cy=h/2,t.setProjectionMatrix(x)}const s=o(),f=o(),m=o(),d=g(),_=t.createColorTexture(n);let x=o(),T=1,h=1,A=1,E=1,w=0,R=0,p=1,F=1;return s[0]=1,s[5]=1,d.h=1,d.cx=.5,d.cy=.5,{color:function(n){t.setTexture(_),t.color=n},putpixel:function(t,n){s[12]=(t-w)*p,s[13]=(n-R)*F,e(s)},draw2DTexture:function(o,r,i,c,u){a(m,r,i,c,u),t.setTexture(o),t.color=n,e(m)},line:r,rect:function(t,n,o,r){o<0&&(t+=o,o=-o),r<0&&(n+=r,r=-r),a(m,t,n,o,r);const i=m[0],c=m[5],u=m[12],l=m[13];m[5]=h,e(m),m[13]=l+c-h,e(m),m[0]=T,m[5]=h-c,e(m),m[12]=u+i-T,e(m)},fillRect:function(t,n,o,r){a(m,t,n,o,r),e(m)},arc:i,circle:function(t,n,e){i(t,n,e,0,2*Math.PI)},window:c,resetWindow:function(){c(0,0,t.canvas.width,t.canvas.height)},restoreWindow:u}}async function h(t){function e(t){const e=o.createTexture(t);r((()=>{t.dirty&&o.updateTexture(e,t),o.setTexture(e),o.color=n,o.draw()}))}const o=x(t),{render:r,start:a,stop:c}=A(),u=o.createColorTexture(n),l=o.canvas,s=t.global&&new Function(t.global)();return await async function t(a){const{update:c}=a;if(c){const t="function"==typeof c?c:new Function("node","global",c);r((()=>t(a,s)))}if(a.box&&function(t){let n=v(g(t));r((()=>{t.dirty&&(n=v(g(t))),o.pushMatrix(n)}))}(a.box),a.fill&&function(t){r((()=>{o.color=t.color||n,o.setTexture(u),o.draw()}))}(a.fill),a.texture&&e(a.texture),a.image&&await async function(t){const n="string"==typeof t.src?await i(t.src):t.src;e({...t,src:n})}(a.image),a.children){const n=Array.isArray(a.children)?a.children:Object.values(a.children);for(const e of n)await t(e)}a.box&&r((()=>o.popMatrix()))}(t.root),t.autoStart&&a(),{canvas:l,start:a,pause:c,destroy(){c(),l.remove()}}}function A(){const t=[];let n,e=!1;function o(){for(const n of t)n();n=requestAnimationFrame(o)}return{render(n){t.push(n)},start(){if(e)throw"Engine already started";o(),e=!0},stop(){cancelAnimationFrame(n),e=!1}}}export{g as Box,o as Matrix,s as Program,u as Shader,d as Texture,e as blackColor,v as composeBox,r as createCanvas,a as createCanvasContext,T as drawEngine,h as engine,t as identity,c as intersect,i as loadImage,f as multiply,l as orthographic,A as renderer,m as updateTexture,x as webgl2,n as whiteColor};export default null;
//# sourceMappingURL=/sm/126b0d1dabc7e137fd77b9ca35368aeb2a76a18cf945afa57358c90a0afa53f9.map