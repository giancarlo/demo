/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@cxl/ui@5.0.0-beta.19/chart-worker.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const t=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);const n=[1,1,1,1];const e=[0,0,0,1];function o(n){return n?new Float32Array(n):t.slice(0)}function r(t,n,e){const o=t.createShader(e);if(!o)throw new Error("Could not create shader.");if(t.shaderSource(o,n),t.compileShader(o),!t.getShaderParameter(o,t.COMPILE_STATUS)){const n=t.getShaderInfoLog(o);throw new Error(`Could not compile shader.\n${n}`)}return o}function a(t,n,e,o,r,a){return new Float32Array([2/(n-t),0,0,0,0,2/(o-e),0,0,0,0,2/(r-a),0,(t+n)/(t-n),(e+o)/(e-o),(r+a)/(r-a),1])}function i({frag:t,vtx:n,canvas:e}){const o=e.getContext("webgl2");if(!o)throw new Error("Could not create webgl2 canvas context");const a=o.createProgram();if(!a)throw new Error("Could not create WebGL Program");const i=r(o,n,o.VERTEX_SHADER),c=r(o,t,o.FRAGMENT_SHADER);if(o.attachShader(a,i),o.attachShader(a,c),o.linkProgram(a),!o.getProgramParameter(a,o.LINK_STATUS))throw o.deleteProgram(a),new Error("Could not create WebGL Program");return{gl:o,glProgram:a}}function c(t,n,e=new Float32Array(16)){const[o,r,a,i,c,u,l,m,s,f,d,_,v,g,h,x]=t,[T,A,w,R,E,F,p,b,P,U,L,D,M,y,B,N]=n;return e[0]=T*o+A*c+w*s+R*v,e[1]=T*r+A*u+w*f+R*g,e[2]=T*a+A*l+w*d+R*h,e[3]=T*i+A*m+w*_+R*x,e[4]=E*o+F*c+p*s+b*v,e[5]=E*r+F*u+p*f+b*g,e[6]=E*a+F*l+p*d+b*h,e[7]=E*i+F*m+p*_+b*x,e[8]=P*o+U*c+L*s+D*v,e[9]=P*r+U*u+L*f+D*g,e[10]=P*a+U*l+L*d+D*h,e[11]=P*i+U*m+L*_+D*x,e[12]=M*o+y*c+B*s+N*v,e[13]=M*r+y*u+B*f+N*g,e[14]=M*a+y*l+B*d+N*h,e[15]=M*i+y*m+B*_+N*x,e}function u(t,n){n.wrapS??=t.CLAMP_TO_EDGE,n.wrapT??=n.wrapS;const e=t.createTexture();if(!e)throw new Error("Could not create texture");return t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,n.wrapS),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,n.wrapT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,n.minFilter??t.NEAREST),n.magFilter&&t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,n.magFilter),n.src&&t.texImage2D(t.TEXTURE_2D,0,n.internalFormat??t.RGBA,n.internalFormat??t.RGBA,t.UNSIGNED_BYTE,n.src),e}function l(t,n){const e=n.map((t=>255*t));return u(t,{src:new ImageData(new Uint8ClampedArray([...e,...e,...e,...e]),2,2),minFilter:t.NEAREST,magFilter:t.NEAREST})}function m({canvas:o}){function r(){const t=g.createBuffer();if(!t)throw new Error("Could not create buffer");return t}function m(t,n,e){g.activeTexture(g.TEXTURE0+e),g.bindTexture(g.TEXTURE_2D,t),g.uniform1i(n,e)}function s(t){g.uniformMatrix4fv(A,!1,t)}function f(t,n,{data:e,size:o,normalized:r,type:a,stride:i,offset:c}){g.bindBuffer(g.ARRAY_BUFFER,t),g.vertexAttribPointer(n,o??2,a??g.FLOAT,r??!1,i??0,c??0),g.bufferData(g.ARRAY_BUFFER,e,g.STATIC_DRAW)}function d(t){t.size??=3,f(D,F,t)}function _(t){S!==t&&(R&&m(t,R,0),S=t)}function v(){d({data:Y.buffer})}const{gl:g,glProgram:h}=i({frag:"#version 300 es\nprecision mediump float;\n\nin vec3 v_normal;\nin vec3 v_position;\nin vec2 v_texcoord;\nin vec3 v_tangent;  \n\nuniform sampler2D u_texture;\nuniform sampler2D u_normalTexture;\nuniform sampler2D u_metallicTexture;\nuniform sampler2D u_roughnessTexture;\nuniform sampler2D u_aoTexture;\nuniform vec3 u_lightPosition;\nuniform vec3 u_cameraPosition;\nuniform vec4 u_color;\n\nuniform int u_renderMode; // 0 = unlit, 1 = PBR lit\n\nout vec4 outColor;\n\n#define PI 3.14159265359\n\n// Function to transform normal from tangent space to world space\nvec3 getNormalFromMap() {\n    vec3 tangentNormal = texture(u_normalTexture, v_texcoord).rgb * 2.0 - 1.0;\n    \n    vec3 N = normalize(v_normal);\n    vec3 T = normalize(v_tangent);\n    vec3 B = normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n    \n    return normalize(TBN * tangentNormal);\n}\n\nvec4 calculateLighting(vec4 albedo, float metallic, float roughness, float ao, vec3 normal, vec3 fragPos) {\n    vec3 lightColor = vec3(1.0);\n    vec3 lightDir = normalize(u_lightPosition - fragPos);\n    vec3 viewDir = normalize(u_cameraPosition - fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    \n    float distance = max(length(u_lightPosition - fragPos), 1e-6);\n    float attenuation = 1.0 / (distance * distance);\n    vec3 radiance = lightColor * attenuation;\n    \n    // Ambient\n    vec4 ambient = ao * albedo;\n    \n    // Diffuse (Lambertian)\n    float dotNormalLight = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = dotNormalLight * albedo.rgb;\n    \n    // Specular (Cook-Torrance BRDF)\n    float roughnessSq = roughness * roughness;\n    \n    // Avoid division by zero\n    float NdotH = max(dot(normal, halfwayDir), 0.0001);\n    float dotNormalView = max(dot(normal, viewDir), 0.0001);\n    float VdotH = max(dot(viewDir, halfwayDir), 0.0001);\n    \n    // Distribution (Trowbridge-Reitz / GGX)\n    float nom = roughnessSq;\n    float denom = (NdotH * NdotH * (roughnessSq - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    float distribution = nom / max(denom, 1e-6);\n    \n    // Fresnel-Schlick approximation with metallic\n    vec3 F0 = mix(vec3(0.04), albedo.rgb, metallic);\n    // Fixed: Use VdotH instead of dot(normal, viewDir)\n    vec3 fresnel = F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n    \n    // Geometry (Smith's method with Schlick-GGX)\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    float GGX1 = dotNormalView / (dotNormalView * (1.0 - k) + k);\n    float GGX2 = dotNormalLight / (dotNormalLight * (1.0 - k) + k);\n    float geometry = GGX1 * GGX2;\n    \n    vec3 specular = (distribution * geometry * fresnel) / max(4.0 * dotNormalLight * dotNormalView, 0.0001);\n    \n    // Only add specular if dotNormalLight is positive\n    vec3 finalSpecular = dotNormalLight > 0.0 ? specular : vec3(0.0);\n    \n    return vec4(ambient.rgb + radiance * (diffuse + finalSpecular), albedo.a);\n}\n\nvoid main() {\n    vec4 albedo = texture(u_texture, v_texcoord) * u_color;\n\t\n\t// UNLIT BRANCH\n    if (u_renderMode == 0) {\n        outColor = albedo;\n        return;\n    }\n    \n    // Use the proper normal map transformation\n    vec3 normal = getNormalFromMap();\n    \n    float metallic = texture(u_metallicTexture, v_texcoord).r;\n    float roughness = texture(u_roughnessTexture, v_texcoord).r;\n    float ao = texture(u_aoTexture, v_texcoord).r;\n    \n    outColor = calculateLighting(albedo, metallic, roughness, ao, normal, v_position);\n}\n",vtx:"#version 300 es\nprecision highp float;\n\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texcoord;\nin vec3 a_tangent;\n/*in vec4 a_model0;\nin vec4 a_model1;\nin vec4 a_model2;\nin vec4 a_model3;*/\n\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_projection;\nuniform mat4 u_normalMatrix;\n\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_texcoord;\nout vec3 v_tangent;\n\nvoid main() {\n    vec4 worldPosition = u_model * vec4(a_position, 1.0);\n    v_position = worldPosition.xyz;\n    v_normal = normalize(mat3(u_normalMatrix) * a_normal);\n    v_tangent = normalize(mat3(u_normalMatrix) * a_tangent);\n    v_texcoord = a_texcoord;\n\n    gl_Position = u_projection * u_view * worldPosition;\n}\n\t\t",canvas:o});g.useProgram(h),g.clearColor(0,0,0,0),g.clear(g.COLOR_BUFFER_BIT|g.DEPTH_BUFFER_BIT),g.enable(g.BLEND),g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),g.blendFunc(g.SRC_ALPHA,g.ONE_MINUS_SRC_ALPHA);const x=g.getUniformLocation(h,"u_model"),T=g.getUniformLocation(h,"u_view"),A=g.getUniformLocation(h,"u_projection"),w=g.getUniformLocation(h,"u_normalMatrix"),R=g.getUniformLocation(h,"u_texture"),E=g.getUniformLocation(h,"u_renderMode"),F=g.getAttribLocation(h,"a_position"),p=g.getAttribLocation(h,"a_texcoord"),b=g.getAttribLocation(h,"a_normal"),P=g.getAttribLocation(h,"a_tangent"),U=g.getUniformLocation(h,"u_color"),L=r(),D=r(),M=r(),y=r(),B=r(),N=a(0,g.canvas.width,g.canvas.height,0,-1,1);let S,I=n;const C=l(g,e),G=l(g,e),X=l(g,e),z=l(g,n);g.bindBuffer(g.ARRAY_BUFFER,M),g.bufferData(g.ARRAY_BUFFER,new Float32Array([0,0,1,0,1,1,1,1,0,1,0,0]),g.STATIC_DRAW);const Y=new Float32Array([0,0,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0]);g.bindBuffer(g.ARRAY_BUFFER,D),g.bufferData(g.ARRAY_BUFFER,Y,g.STATIC_DRAW),g.enableVertexAttribArray(F),g.vertexAttribPointer(F,3,g.FLOAT,!1,0,0);const H=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1]);g.bindBuffer(g.ARRAY_BUFFER,y),g.bufferData(g.ARRAY_BUFFER,H,g.STATIC_DRAW),g.enableVertexAttribArray(b),g.vertexAttribPointer(b,3,g.FLOAT,!1,0,0);const V=new Float32Array([1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0]);g.bindBuffer(g.ARRAY_BUFFER,L),g.bufferData(g.ARRAY_BUFFER,V,g.STATIC_DRAW),g.enableVertexAttribArray(P),g.vertexAttribPointer(P,3,g.FLOAT,!1,0,0),g.uniformMatrix4fv(x,!1,t),g.uniformMatrix4fv(T,!1,t),g.uniformMatrix4fv(A,!1,N),g.uniformMatrix4fv(w,!1,t),g.bindBuffer(g.ARRAY_BUFFER,M),g.enableVertexAttribArray(p),g.vertexAttribPointer(p,2,g.FLOAT,!1,0,0),g.uniform4fv(U,I);const O=[],W=g.getUniformLocation(h,"u_normalTexture"),k=g.getUniformLocation(h,"u_metallicTexture"),j=g.getUniformLocation(h,"u_roughnessTexture"),q=g.getUniformLocation(h,"u_aoTexture"),K=g.getUniformLocation(h,"u_lightPosition"),$=g.getUniformLocation(h,"u_cameraPosition");let J=t;return g.uniform3fv(K,[.5,.5,1]),g.uniform3fv($,[0,0,1]),W&&m(C,W,1),k&&m(G,k,2),j&&m(X,j,3),q&&m(z,q,4),g.viewport(0,0,g.canvas.width,g.canvas.height),g.activeTexture(g.TEXTURE0),s(N),v(),{canvas:g.canvas,clear:function(){g.clear(g.COLOR_BUFFER_BIT|g.DEPTH_BUFFER_BIT)},resizeViewport:function(t,n){g.viewport(0,0,t,n)},setRenderMode:function(t){g.uniform1i(E,"draw"===t?0:1)},pushMatrix(n){O.push(J),n!==t&&(J=J===t?n:c(J,n),g.uniformMatrix4fv(x,!1,J))},popMatrix(){const t=O.pop();if(!t)throw new Error("Matrix stack empty");J=t,g.uniformMatrix4fv(x,!1,t)},get color(){return I},set color(t){t!==I&&g.uniform4fv(U,I=t)},setIndices:function(t){g.bindBuffer(g.ELEMENT_ARRAY_BUFFER,B),g.bufferData(g.ELEMENT_ARRAY_BUFFER,t,g.STATIC_DRAW)},setPosition:d,setNormal:function(t){t.size??=3,f(y,b,t)},setProjectionMatrix:s,setNormalMatrix:function(t){g.uniformMatrix4fv(w,!1,t)},resetPosition:v,resetProjectionMatrix(){s(N)},setTexture:_,createTexture:u.bind(0,g),createColorTexture:l.bind(0,g),updateTexture(t,n){_(t),g.texImage2D(g.TEXTURE_2D,0,n.internalFormat??g.RGBA,n.internalFormat??g.RGBA,g.UNSIGNED_BYTE,n.src)},draw(){g.drawArrays(g.TRIANGLES,0,6)},drawElements:g.drawElements.bind(g)}}function s(t,n=new Float32Array(16)){const{x:e,y:o,sx:r,sy:a,cx:i,cy:c,w:u,h:l,rotation:m}=t;n[2]=n[3]=n[6]=n[7]=n[8]=n[9]=n[11]=n[14]=0,n[10]=n[15]=1;const s=Math.cos(m),f=Math.sin(m);return n[0]=r*s,n[1]=r*f,n[4]=a*-f,n[5]=a*s,n[12]=n[0]*-i+n[4]*-c+e,n[13]=n[1]*-i+n[5]*-c+o,n[0]*=u,n[1]*=u,n[4]*=l,n[5]*=l,n}function f(t){return{x:0,y:0,w:0,h:0,sx:1,sy:1,cx:0,cy:0,rotation:0,...t}}function d(t){function e(n){t.pushMatrix(n),t.draw(),t.popMatrix()}function r(t,n,o,r){const a=(t-R)*F,i=(n-E)*p,c=(o-R)*F,u=(r-E)*p,l=Math.hypot(c-a,u-i),m=Math.atan2(u-i,c-a);v.x=a,v.y=i,v.w=l,v.rotation=m,s(v,d),e(d)}function i(t,n,e,o,r){t[0]=o*F,t[5]=r*p,t[12]=(n-R)*F,t[13]=(e-E)*p}function c(t,n,e,o,a,i){const c=Math.PI/e/4;(o%=2*Math.PI)>=(a%=2*Math.PI)&&(a+=2*Math.PI);let u=t+Math.cos(o)*e,l=n-Math.sin(o)*e;for(let i=o+c;i<a;i+=c)r(u,l,u=t+Math.cos(i)*e,l=n-Math.sin(i)*e)}function u(n,e,o,r){h=a(0,1,0,1,-1,1),R=n,E=e,F=1/(o-n),p=1/(r-e),A=1/t.canvas.width,w=1/t.canvas.height,l()}function l(){m[0]=x=A,m[5]=T=w,v.h=T,v.cx=x/2,v.cy=T/2,t.setProjectionMatrix(h)}const m=o(),d=o(),_=o(),v=f(),g=t.createColorTexture(n);let h=o(),x=1,T=1,A=1,w=1,R=0,E=0,F=1,p=1;return m[0]=1,m[5]=1,v.h=1,v.cx=.5,v.cy=.5,{color:function(n){t.setTexture(g),t.color=n},putpixel:function(t,n){m[12]=(t-R)*F,m[13]=(n-E)*p,e(m)},draw2DTexture:function(o,r,a,c,u){i(_,r,a,c,u),t.setTexture(o),t.color=n,e(_)},line:r,rect:function(t,n,o,r){o<0&&(t+=o,o=-o),r<0&&(n+=r,r=-r),i(_,t,n,o,r);const a=_[0],c=_[5],u=_[12],l=_[13];_[5]=T,e(_),_[13]=l+c-T,e(_),_[0]=x,_[5]=T-c,e(_),_[12]=u+a-x,e(_)},fillRect:function(t,n,o,r){i(_,t,n,o,r),e(_)},arc:c,circle:function(t,n,e){c(t,n,e,0,2*Math.PI)},window:u,resetWindow:function(){u(0,0,t.canvas.width,t.canvas.height)},restoreWindow:l}}let _,v,g,h,x,T,A,w=[],R=!0,E=!1;async function F(t){h=m({canvas:t}),x=d(h),T=await v({draw:x,gl:h,data:A}),x.window(g.x,g.y,g.x+g.w,g.y+g.h),E=!0,p()}function p(){for(const t of w)T.render(t,g)}self.onmessage=t=>{const n=t.data;"load"===n.type?(_=n.canvas,A=n.data,v=new Function("a",`return (${n.workerFn})(a)`)):"render"===n.type?(n.data&&w.push(n.data),E&&p()):"resize"===n.type?(g=n.view,_.width===n.width&&_.height===n.height||(_.width=n.width,_.height=n.height,h?.resizeViewport(n.width,n.height)),E&&(x.window(g.x,g.y,g.x+g.w,g.y+g.h),p())):"reset"===n.type&&(w=[],h?.clear()),R&&w&&g&&(R=!1,F(_))};
//# sourceMappingURL=/sm/dada6aaadce34cf3db520c51aa05bf85b820ebf1fc7e2c56094e8920a4d9b749.map